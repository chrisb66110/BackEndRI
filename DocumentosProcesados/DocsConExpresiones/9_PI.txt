 c por qu no deber usar referencias a punteros inteligentes coredump uno navegaci de palanca coredump uno preguntas etiquetas aqu podr ser tu publicidad por qu no deber usar referencias a punteros inteligentes votos 24 recuerdo leer en alguna parte que el uso de referencias a punteros inteligentes puede causar da en la memoria esto se debe simplemente al uso de la referencia del puntero inteligente despu de su destrucci o el recuento de referencias se estropea gracias por aclararlo c smart pointers publicado el 07 10 2008 a las 04 41 fuente por usuario superpolock 6 respuestas votos 14 asumiendo que est s hablando de shared aqu esto se debe simplemente al uso de la referencia del puntero inteligente despu de su destrucci esta es una buena respuesta es posible que no sepa absolutamente la vida del puntero a la que se refiere su referencia tambi para evitar esto querr ver boost weak no participa en el recuento de referencias cuando necesitas usarlo te da un shared que desaparece una vez que hayas terminado con tambi le permitir saber cu ndo se ha recopilado el puntero al referido de la documentaci de weak la plantilla de la clase weak almacena una d para un objeto que ya est administrado por un shared para acceder al objeto un weak se puede convertir a un shared utilizando el constructor shared o el bloqueo de funci miembro cuando el shared del objeto desaparece y el objeto se elimina el intento de obtener un shared de las instancias weak que hacen referencia al objeto eliminado fallar el constructor arrojar una excepci de tipo boost bad y weak lock devolver un shared vac tenga en cuenta que el m caducado tambi le indicar si su ptr a est activo respondida el 07 10 2008 a las 04 44 fuente por usuario doug t aqu podr ser tu publicidad votos 5 cuando se utilizan punteros inteligentes cualquier objeto de gesti de asignaci se cuenta con los comportamientos definidos en el constructor destructor para gestionar refs derefs locks unlocks como resultado esos tipos de objetos deben ser objetos verdaderos para funcionar correctamente cuando se utilizan referencias a tales objetos se est pasando por alto el mecanismo pidiendo un respondida el 07 10 2008 a las 05 08 fuente por usuario dan hewett votos 3 todav hay muchos casos en los que una referencia a un puntero inteligente es una buena idea un ejemplo obvio es el m de asignaci de la clase de puntero inteligente que acepta una referencia a otro puntero inteligente como su par metro hacer un m que acepte una referencia de puntero inteligente significa que el par metro no incrementa la cuenta de referencia interna del puntero inteligente esto puede mejorar el rendimiento pero probablemente no mucho adem s hay muchas cosas que el m no puede hacer con la referencia o con el puntero inteligente original si sabes lo que son estas cosas y las evitas pasar por referencia funciona muy bien por supuesto el prop de los indicadores inteligentes es evitar tener que saber estas cosas adem s si tiene un m que modificar el valor de un par metro de puntero inteligente se requiere pasar como referencia como ocurre con cualquier otro tipo respondida el 07 10 2008 a las 05 48 fuente por usuario jeff b votos 1 la parte de los punteros inteligentes es administrada por los constructores destructores operadores de asignaci y otras funciones de la clase de puntero inteligente al usar una referencia est eludiendo estas operaciones no se llamar al constructor cuando se inicialice su referencia y no se llamar al destructor cuando su referencia quede fuera del alcance en esencia una referencia a un puntero inteligente es un puntero tonto con todos los riesgos y trampas que este implica respondida el 07 10 2008 a las 05 49 fuente por usuario johnmcg votos 0 pasando una referencia a un puntero inteligente en una funci es perfectamente seguro y es una buena idea el objeto puede desaparecer pero el puntero inteligente no va a ser sentado all diciendo nulo al menos hasta que se devuelve la funci es la mejor manera de poner un alias para un puntero inteligente dentro de su alcance si utiliza una referencia con un modificador const en lo que se refiere a continuaci usted tiene una referencia de la observaci inteligente const smart es interesante y la const le impide utilizar la referencia decir anular el puntero inteligente y eliminar el objeto pero no detiene el puntero inteligente original del mismo y anulando su referencia reflejar ese cambio volviendo una referencia a puntero inteligente de una funci es pidiendo todo tipo de problemas respondida el 01 10 2013 a las 03 10 fuente por usuario john morrison votos 0 tenemos smartpointers personalizados y siempre tenemos el h bito de pasar un const refsomething no incrementa ni disminuye el puntero inteligente y como tal y m s importante a se evitan las llamadas a interlockedincrement decrement que a su vez evita una valla de memoria y todas las cosas que lo acompa bloqueo de bus invalidaci de cach respondida el 07 10 2008 a las 07 14 fuente por usuario qbziz aqu podr ser tu publicidad licensed under cc by sa 3 0 with attribution required 